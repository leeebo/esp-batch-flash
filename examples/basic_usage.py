#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ESP Batch Flash - Basic Usage Example

This example demonstrates how to use the ESP Batch Flash library 
programmatically to flash multiple ESP devices in parallel.

Usage:
1. Create a virtual environment: python -m venv venv
2. Activate it: source venv/bin/activate (Linux/Mac) or venv\\Scripts\\activate (Windows)
3. Install requirements: pip install esptool pyserial
4. Connect multiple ESP devices to your computer
5. Run this script: python basic_usage.py

If you don't have actual ESP devices connected, you can run in mock mode:
   python basic_usage.py --mock
"""

import os
import sys
import time
import argparse
from concurrent.futures import ThreadPoolExecutor

from esp_batch_flash.base import (
    find_serial_ports, 
    check_dependencies,
    parse_flash_args,
    flash_device,
    FlashProgress,
    progress_output_lock,
    progress_lock,
    device_progress
)

def setup_example_flash_args():
    """
    Create an example flash_args file and dummy binary files for demonstration.
    
    In a real scenario, these files would be generated by your ESP-IDF build.
    """
    current_dir = os.path.dirname(os.path.abspath(__file__))
    flash_args_file = os.path.join(current_dir, 'flash_args_example')
    
    # Make sure the flash_args file exists
    if not os.path.exists(flash_args_file):
        print(f"Creating example flash_args file at: {flash_args_file}")
        with open(flash_args_file, 'w') as f:
            f.write("--flash_mode dio --flash_freq 80m --flash_size 4MB\n")
            f.write("0x1000 bootloader.bin\n")
            f.write("0x8000 partition-table.bin\n")
            f.write("0x10000 firmware.bin\n")
    
    # Create dummy binary files for the example
    # In a real scenario, these would be your actual firmware files
    for bin_file in ['bootloader.bin', 'partition-table.bin', 'firmware.bin']:
        bin_path = os.path.join(current_dir, bin_file)
        if not os.path.exists(bin_path):
            print(f"Creating dummy {bin_file} for demonstration")
            with open(bin_path, 'wb') as f:
                # Write some dummy data (1KB)
                f.write(b'\x00' * 1024)
    
    return flash_args_file

# Import mock functionality from the main package
from esp_batch_flash.mock import get_mock_serial_ports, mock_flash_device

def main():
    # Parse command line arguments
    parser = argparse.ArgumentParser(description='ESP Batch Flash example')
    parser.add_argument('--max-parallel', type=int, default=3, 
                       help='Maximum number of parallel flash operations')
    parser.add_argument('--baud', type=int, default=1152000, 
                       help='Baud rate for flashing')
    parser.add_argument('--no-progress', action='store_true', 
                       help='Disable progress bars')
    parser.add_argument('--mock', action='store_true',
                       help='Run in mock mode without actual ESP devices')
    parser.add_argument('--mock-ports', type=int, default=3,
                       help='Number of mock ports to simulate when in mock mode')
    parser.add_argument('--skip-deps-check', action='store_true',
                       help='Skip dependencies check (useful in mock mode or for testing)')
    args = parser.parse_args()
    
    # Step 1: Check dependencies (esptool must be installed) - skip in mock mode if requested
    print("Step 1: Checking dependencies...")
    if args.mock and args.skip_deps_check:
        print("Skipping dependency check in mock mode")
    else:
        check_dependencies()
    
    # Step 2: Find all connected ESP devices or use mock ports
    print("\nStep 2: Finding ESP devices...")
    if args.mock:
        ports = get_mock_serial_ports(args.mock_ports)
        print(f"Running in MOCK MODE with {len(ports)} simulated devices:")
    else:
        ports = find_serial_ports()
        if not ports:
            print("No ESP devices found! Please connect your ESP devices or use --mock mode.")
            print("Run with --mock to simulate devices without actual hardware.")
            sys.exit(1)
        print(f"Found {len(ports)} real ESP devices:")
    
    for port in ports:
        print(f"  - {port}")
    
    # Step 3: Set up flash_args and prepare binary files
    print("\nStep 3: Setting up flash configuration...")
    flash_args_file = setup_example_flash_args()
    current_dir = os.path.dirname(os.path.abspath(__file__))
    
    # Step 4: Parse flash_args file to get flash options and binary files
    print(f"Parsing flash_args file: {flash_args_file}")
    flash_options, binary_files = parse_flash_args(flash_args_file, current_dir, current_dir)
    
    print("\nFlash options:")
    print(f"  {' '.join(flash_options)}")
    
    print("\nBinary files to flash:")
    for addr, path in binary_files:
        print(f"  {addr}: {path}")
    
    # Step 5: Create log directory
    log_dir = os.path.join(os.path.dirname(current_dir), 'log')
    os.makedirs(log_dir, exist_ok=True)
    
    # Step 6: Flash all devices in parallel
    max_parallel = args.max_parallel
    baud_rate = args.baud
    show_progress = not args.no_progress
    
    print(f"\nStep 6: Starting parallel flashing to {len(ports)} devices...")
    print(f"  - Maximum parallel operations: {max_parallel}")
    print(f"  - Baud rate: {baud_rate}")
    print(f"  - Progress bars: {'Enabled' if show_progress else 'Disabled'}")
    
    if args.mock:
        print("\nNOTE: Running in MOCK MODE. No actual flashing will occur.")
    
    # Reserve space for progress bars
    if show_progress:
        with progress_output_lock:
            for _ in range(len(ports)):
                print()
    
    # Start parallel flashing
    with ThreadPoolExecutor(max_workers=max_parallel) as executor:
        # Submit tasks for all ports - use mock function if in mock mode
        flash_func = mock_flash_device if args.mock else flash_device
        futures = [executor.submit(flash_func, 
                                  port, 
                                  flash_options, 
                                  binary_files, 
                                  log_dir, 
                                  'auto',  # Auto-detect chip type
                                  baud_rate) 
                  for port in ports]
        
        # Monitor progress
        all_done = False
        try:
            while not all_done:
                if show_progress:
                    FlashProgress.print_progress_bars()
                
                all_done = all(future.done() for future in futures)
                time.sleep(0.2)
                
            print("\n\nAll flash operations completed!")
            
            # Collect results
            results = [future.result() for future in futures]
            success_count = sum(1 for success, _ in results if success)
            
            print(f"\nResults summary:")
            print(f"  - Total devices: {len(ports)}")
            print(f"  - Successfully flashed: {success_count}")
            print(f"  - Failed: {len(ports) - success_count}")
            
            if log_dir:
                print(f"\nCheck the logs in {log_dir} for detailed information")
            
        except KeyboardInterrupt:
            print("\n\nInterrupted by user! Cancelling tasks...")
            for future in futures:
                future.cancel()
            executor.shutdown(wait=False)
            sys.exit(1)

if __name__ == "__main__":
    main()